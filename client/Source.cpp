/*
* Copyright (c) 2014 Cesanta Software Limited
* All rights reserved
* This software is dual-licensed: you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 as
* published by the Free Software Foundation. For the terms of this
* license, see <http://www.gnu.org/licenses/>.
*
* You are free to use this software under the terms of the GNU General
* Public License, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
* See the GNU General Public License for more details.
*
* Alternatively, you can license this software under a commercial
* license, as set out in <https://www.cesanta.com/license>.
*/

// find libs here C:\OpenCV\opencv-3.3.1\build\install\x64\vc15\lib

#include "mongoose.h"
#include <iostream>
#include <fstream>
#include <stdio.h>
#include <iostream>
#include <vector>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/stitching.hpp"
#include "opencv2/core/core.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/video/background_segm.hpp"
#include "opencv2/bgsegm.hpp"

#include "json.hpp"

// for convenience
using json = nlohmann::json;

/*
int test(){
	cv::Mat back;
	cv::Mat fore;
	pMOG2 = cv::createBackgroundSubtractorMOG2(); //MOG2 approach
	cv::BackgroundSubtractorMOG2 bg(5, 3, true);
	cv::namedWindow("Background");
	std::vector<std::vector<cv::Point> > contours;

	bg.operator ()(frame, fore);
	bg.getBackgroundImage(back);
	cv::erode(fore, fore, cv::Mat());
	cv::dilate(fore, fore, cv::Mat());
	cv::findContours(fore, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);
	cv::drawContours(frame, contours, -1, cv::Scalar(0, 0, 255), 2);
	return frame;
}
*/

// add some json, image stuff and good to go

static const char *s_address = "127.0.0.1:1883";// "192.168.88.100:1883";
static const char *s_user_name = NULL;
static const char *s_password = NULL;
static struct mg_mqtt_topic_expression s_topic_expr = { NULL, 0 };
bool try_use_gpu = false;
cv::Stitcher::Mode mode = cv::Stitcher::PANORAMA;
std::vector<cv::Mat> imgs;
std::string result_name = "result.jpg";
cv::Mat frame; //current frame
cv::Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
cv::Ptr<cv::BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
char keyboard; //input from keyboard
char datatopic[128];//bugbug rm magic 
static const char *s_topic = "/stuff";

static void ev_handler(struct mg_connection *nc, int ev, void *p) {
	struct mg_mqtt_message *msg = (struct mg_mqtt_message *) p;
	(void)nc;

	if (ev != MG_EV_POLL) printf("USER HANDLER GOT EVENT %d\n", ev);

	switch (ev) {
	case MG_EV_CONNECT: {
		struct mg_send_mqtt_handshake_opts opts;
		memset(&opts, 0, sizeof(opts));
		opts.user_name = s_user_name;
		opts.password = s_password;

		mg_set_protocol_mqtt(nc);
		mg_send_mqtt_handshake_opt(nc, "dummy", opts);
		break;
	}
	case MG_EV_MQTT_CONNACK:
		if (msg->connack_ret_code != MG_EV_MQTT_CONNACK_ACCEPTED) {
			printf("Got mqtt connection error: %d\n", msg->connack_ret_code);
			exit(1);
		}
		// setup upon connections
		//s_topic_expr.topic = s_topic;
		//printf("Subscribing to '%s'\n", s_topic);
		//mg_mqtt_subscribe(nc, &s_topic_expr, 1, 42);
		{
			struct mg_mqtt_topic_expression topicExpression;
			topicExpression.qos = 0;
			topicExpression.topic = "error";
			mg_mqtt_subscribe(nc, &topicExpression, 1, 13);
			topicExpression.topic = "trace";
			mg_mqtt_subscribe(nc, &topicExpression, 1, 14);
			topicExpression.topic = "dataready"; // json holds machine info
			mg_mqtt_subscribe(nc, &topicExpression, 1, 15);
			topicExpression.topic = "datafinal";
			mg_mqtt_subscribe(nc, &topicExpression, 1, 16);
			topicExpression.topic = "datacam1"; // every device needs this so no json etc need be sent
			mg_mqtt_subscribe(nc, &topicExpression, 1, 17); // can I subscribe only here?
			//mg_mqtt_publish(nc, "/test", 65, MG_MQTT_QOS(0), "hi", 2);
		}
		break;
	case MG_EV_MQTT_PUBACK:
		printf("Message publishing acknowledged (msg_id: %d)\n", msg->message_id);
		break;
	case MG_EV_MQTT_SUBACK:
		printf("Subscription acknowledged (msg_id: %d)\n", msg->message_id);
		//printf("Subscription acknowledged, forwarding to '/test'\n");
		break;
	case MG_EV_MQTT_PUBLISH: {
#if 0
		char hex[1024] = { 0 };
		mg_hexdump(nc->recv_mbuf.buf, msg->payload.len, hex, sizeof(hex));
		printf("Got incoming message %.*s:\n%s", (int)msg->topic.len, msg->topic.p, hex);
#else
		//printf("Got incoming message %.*s: %.*s\n", (int)msg->topic.len,
			//msg->topic.p, (int)msg->payload.len, msg->payload.p);
#endif
		/*
		void mg_mqtt_unsubscribe(struct mg_connection *nc, char **topics,
                         size_t topics_len, uint16_t message_id);
		*/

		// need to support > 1 camera soon

		if (mg_mqtt_vmatch_topic_expression("trace", msg->topic)) {
			// echo json and all at least for now
			printf("Trace message %.*s: %.*s\n", (int)msg->topic.len, msg->topic.p, (int)msg->payload.len, msg->payload.p);
		}
		else if (mg_mqtt_vmatch_topic_expression("error", msg->topic)) {
			printf("ERROR message %.*s: %.*s\n", (int)msg->topic.len, msg->topic.p, (int)msg->payload.len, msg->payload.p);
		}
		else if (mg_mqtt_vmatch_topic_expression("dataready", msg->topic)) {
			std::string s(msg->payload.p, msg->payload.len); // not null terminated
			json j = json::parse(s);
			std::string path = j["path"];
			std::string name = j["name"];
			printf("data ready %s %s\n", name.c_str(), path.c_str());
			// create the file but this will
			//need OpenCV wstream = fs.createWriteStream(cam1);
		}
		else if (mg_mqtt_vmatch_topic_expression("datafinal", msg->topic)) {
			std::string s(msg->payload.p, msg->payload.len); // not null terminated
			json j = json::parse(s);
			std::string path = j["path"];
			printf("data final (EOF) %s\n", path.c_str());
			//wstream.end();
		}
		else if (mg_mqtt_vmatch_topic_expression("datacam1", msg->topic)) {
			printf("raw data len %zd\n", msg->payload.len);
			//mg_hexdump(nc->recv_mbuf.buf, msg->payload.len, hex, sizeof(hex));
			//wstream.write(message);
		}
		return;
		std::string path = "C:\\projects\\engine\\";
		for (int i = 0; i < msg->payload.len; ++i) {
			path += msg->payload.p[i];
		}
		size_t len = path.length();
		cv::Mat background;
		cv::Mat foreground;
		cv::Mat frame = cv::imread(path);
		std::vector<std::vector<cv::Point> > contours;
		if (!frame.empty()) {
			pMOG2->apply(frame, fgMaskMOG2);
			pMOG2->getBackgroundImage(background);
			imshow("back", background);
			imshow("Frame", frame);
			imshow("FG Mask MOG 2", fgMaskMOG2);
			//cv::imshow("Display window", img);
			cv::waitKey(25);
		}
		printf("Forwarding to /test\n");
		mg_mqtt_publish(nc, "/test", 65, MG_MQTT_QOS(0), msg->payload.p,
			msg->payload.len);
		break;
	}
	case MG_EV_CLOSE:
		printf("Connection closed\n");
		exit(1);
	}
}

int main(int argc, char **argv) {
	cv::namedWindow("back", cv::WINDOW_AUTOSIZE);
	cv::namedWindow("Frame", cv::WINDOW_AUTOSIZE);
	cv::namedWindow("FG Mask MOG 2", cv::WINDOW_AUTOSIZE);
	//create Background Subtractor objects
	pMOG2 = cv::createBackgroundSubtractorMOG2(); //MOG2 approach

	struct mg_mgr mgr;

	// bw? image = cv::imread(img1, CV_LOAD_IMAGE_COLOR);   // Read the file

	/* stretch later
	cv::Mat pano;
	cv::Ptr<cv::Stitcher> stitcher = cv::Stitcher::create(mode, try_use_gpu);
	cv::Stitcher::Status status = stitcher->stitch(imgs, pano);
	if (status != cv::Stitcher::OK)	{
		std::cout << "Can't stitch images, error code = " << int(status) << std::endl;
		//return -1;
	}
	imwrite(result_name, pano);
	*/
	mg_mgr_init(&mgr, NULL);

	if (mg_connect(&mgr, s_address, ev_handler) == NULL) {
		fprintf(stderr, "mg_connect(%s) failed\n", s_address);
		exit(EXIT_FAILURE);
	}

	for (;;) {
		mg_mgr_poll(&mgr, 1000);
	}
}
